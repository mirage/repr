<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Repr (repr.Repr)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">repr</a> &#x00BB; Repr</nav><header class="odoc-preamble"><h1>Module <code><span>Repr</span></code></h1><p>Yet-another type combinator library</p><p><code>Repr</code> provides type combinators to define runtime representation for OCaml types and <a href="#generics">generic operations</a> to manipulate values with a runtime type representation.</p><p>The type combinators supports all the usual <a href="#primitives">type primitives</a> but also compact definitions of <a href="#records">records</a> and <a href="#variants">variants</a>. It also allows the definition of run-time representations of <a href="#recursive">recursive types</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#type-combinators">Type Combinators</a></li><li><a href="#primitives">Primitives</a></li><li><a href="#records">Records</a></li><li><a href="#variants">Variants</a></li><li><a href="#recursive">Recursive definitions</a></li><li><a href="#staging">Staging</a></li><li><a href="#generics">Generic Operations</a><ul><li><a href="#json-converters">JSON converters</a></li><li><a href="#binary-converters">Binary Converters</a></li></ul></li><li><a href="#abstract-types">Abstract types</a><ul><li><a href="#overriding-specific-operations">Overriding specific operations</a></li></ul></li><li><a href="#miscellaneous-modules">Miscellaneous modules</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><div class="odoc-include"><div class="odoc-include"><h2 id="type-combinators"><a href="#type-combinators" class="anchor"></a>Type Combinators</h2><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>The type for runtime representation of values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-len" class="anchored"><a href="#type-len" class="anchor"></a><code><span><span class="keyword">type</span> len</span><span> = </span><span>[ </span></code><table><tr id="type-len.Int" class="anchored"><td class="def constructor"><a href="#type-len.Int" class="anchor"></a><code><span>| </span></code><code><span>`Int</span></code></td></tr><tr id="type-len.Int8" class="anchored"><td class="def constructor"><a href="#type-len.Int8" class="anchor"></a><code><span>| </span></code><code><span>`Int8</span></code></td></tr><tr id="type-len.Int16" class="anchored"><td class="def constructor"><a href="#type-len.Int16" class="anchor"></a><code><span>| </span></code><code><span>`Int16</span></code></td></tr><tr id="type-len.Int32" class="anchored"><td class="def constructor"><a href="#type-len.Int32" class="anchor"></a><code><span>| </span></code><code><span>`Int32</span></code></td></tr><tr id="type-len.Int64" class="anchored"><td class="def constructor"><a href="#type-len.Int64" class="anchor"></a><code><span>| </span></code><code><span>`Int64</span></code></td></tr><tr id="type-len.Fixed" class="anchored"><td class="def constructor"><a href="#type-len.Fixed" class="anchor"></a><code><span>| </span></code><code><span>`Fixed <span class="keyword">of</span> int</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type of integer used to store buffers, list or array lengths.</p><p><code>Int</code> use a (compressed) variable encoding to encode integers in a binary format, while <code>IntX</code> always use <code>X</code> bytes. Overflows are not detected.</p></div></div><h2 id="primitives"><a href="#primitives" class="anchor"></a>Primitives</h2><div class="odoc-spec"><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unit</code> is a representation of the unit type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bool" class="anchored"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bool</code> is a representation of the boolean type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>char</code> is a representation of the character type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int" class="anchored"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int</code> is a representation of integers. Binary serialization uses a varying-width representation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int32" class="anchored"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int32</code> is a representation of the 32-bit integer type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int63" class="anchored"><a href="#val-int63" class="anchor"></a><code><span><span class="keyword">val</span> int63 : <span><span class="xref-unresolved">Optint</span>.Int63.t <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int63</code> is a representation of the 63-bit integer type supplied by the <code>Optint</code> library.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int64" class="anchored"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <span>int64 <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int64</code> is a representation of the 64-bit integer type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-float" class="anchored"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>float</code> is a representation of the <code>float</code> type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>string</code> is a representation of the <code>string</code> type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes" class="anchored"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span>bytes <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bytes</code> is a representation of the <code>bytes</code> type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of" class="anchored"><a href="#val-string_of" class="anchor"></a><code><span><span class="keyword">val</span> string_of : <span><a href="#type-len">len</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-string"><code>string</code></a> but with a given kind of size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes_of" class="anchored"><a href="#val-bytes_of" class="anchor"></a><code><span><span class="keyword">val</span> bytes_of : <span><a href="#type-len">len</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-bytes"><code>bytes</code></a> but with a given kind of size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-boxed" class="anchored"><a href="#val-boxed" class="anchor"></a><code><span><span class="keyword">val</span> boxed : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>boxed t</code> is the same as <code>t</code> but with a binary representation which is always boxed (e.g. top-level values won't be unboxed). This forces <a href="Unboxed/index.html"><code>Unboxed</code></a> functions to be exactly the same as boxed ones.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span>?len:<a href="#type-len">len</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>list t</code> is a representation of lists of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array" class="anchored"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span>?len:<a href="#type-len">len</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>array t</code> is a representation of arrays of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-option" class="anchored"><a href="#val-option" class="anchor"></a><code><span><span class="keyword">val</span> option : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>option t</code> is a representation of values of type <code>t option</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pair" class="anchored"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pair x y</code> is a representation of values of type <code>x * y</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-triple" class="anchored"><a href="#val-triple" class="anchor"></a><code><span><span class="keyword">val</span> triple : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>triple x y z</code> is a representation of values of type <code>x * y * z</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-result" class="anchored"><a href="#val-result" class="anchor"></a><code><span><span class="keyword">val</span> result : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>result a b</code> is a representation of values of type <code>(a, b) result</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-either" class="anchored"><a href="#val-either" class="anchor"></a><code><span><span class="keyword">val</span> either : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Either</span>.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>either a b</code> is a representation of values of type <code>(a, b) Either.t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq" class="anchored"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq t</code> is a representation of sequences of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ref" class="anchored"><a href="#val-ref" class="anchor"></a><code><span><span class="keyword">val</span> ref : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.ref</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ref t</code> is a representation of references to values of type <code>t</code>.</p><p><b>Note</b>: derived deserialisation functions will not preserve reference sharing.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lazy_t" class="anchored"><a href="#val-lazy_t" class="anchor"></a><code><span><span class="keyword">val</span> lazy_t : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Lazy.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lazy_t t</code> is a representation of lazy values of type <code>t</code>.</p><p><b>Note</b>: derived deserialisation functions on the resulting type will not be lazy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-queue" class="anchored"><a href="#val-queue" class="anchor"></a><code><span><span class="keyword">val</span> queue : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Queue.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>queue t</code> is a representation of queues of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stack" class="anchored"><a href="#val-stack" class="anchor"></a><code><span><span class="keyword">val</span> stack : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Stack.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>stack t</code> is a representation of stacks of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hashtbl" class="anchored"><a href="#val-hashtbl" class="anchor"></a><code><span><span class="keyword">val</span> hashtbl : <span><span><span class="type-var">'k</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'v</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>hashtbl k v</code> is a representation of hashtables with keys of type <code>k</code> and values of type <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><span>(<span class="keyword">module</span> <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="type-var">'elt</span> <span class="keyword">and</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'set</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'elt</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'set</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>set (module Set) elt</code> is a representation of sets with elements of type <code>elt</code>. See <a href="Of_set/index.html"><code>Of_set</code></a> for a functorised equivalent of this function.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Of_set" class="anchored"><a href="#module-Of_set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Of_set/index.html">Of_set</a></span><span> (<a href="Of_set/argument-1-Set/index.html">Set</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Functor for building representatives of <i>sets</i> from the standard library.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Of_map" class="anchored"><a href="#module-Of_map" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Of_map/index.html">Of_map</a></span><span> (<a href="Of_map/argument-1-Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Functor for building representatives of <i>maps</i> from the standard library.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-empty" class="anchored"><a href="#type-empty" class="anchor"></a><code><span><span class="keyword">type</span> empty</span><span> = </span><span>|</span></code></div><div class="spec-doc"><p>An uninhabited type, defined as a variant with no constructors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><a href="#type-empty">empty</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>empty</code> is a representation of the <a href="#type-empty"><code>empty</code></a> type.</p></div></div><h2 id="records"><a href="#records" class="anchor"></a>Records</h2><div class="odoc-spec"><div class="spec type" id="type-open_record" class="anchored"><a href="#type-open_record" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c) open_record</span></span></code></div><div class="spec-doc"><p>The type for representing open records of type <code>'a</code> with a constructor of type <code>'b</code>. <code>'c</code> represents the remaining fields to be described using the <a href="#val-(|+)"><code>(|+)</code></a> operator. An open record initially satisfies <code>'c = 'b</code> and can be <a href="#val-sealr">sealed</a> once <code>'c = 'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-record" class="anchored"><a href="#val-record" class="anchor"></a><code><span><span class="keyword">val</span> record : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>)</span> <a href="#type-open_record">open_record</a></span></span></code></div><div class="spec-doc"><p><code>record n f</code> is an incomplete representation of the record called <code>n</code> of type <code>'a</code> with constructor <code>f</code>. To complete the representation, add fields with <a href="#val-(|+)"><code>(|+)</code></a> and then seal the record with <a href="#val-sealr"><code>sealr</code></a>.</p><p>The name <code>n</code> is used for non-binary encoding/decoding and for pretty printing.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-field" class="anchored"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) field</span></span></code></div><div class="spec-doc"><p>The type for fields holding values of type <code>'b</code> and belonging to a record of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-field" class="anchored"><a href="#val-field" class="anchor"></a><code><span><span class="keyword">val</span> field : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'a</span>)</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p><code>field n t g</code> is the representation of the field called <code>n</code> of type <code>t</code> with getter <code>g</code>. <b>Raises.</b> <code>Invalid_argument</code> if <code>n</code> is not valid UTF-8.</p><p>The name <code>n</code> is used for non-binary encoding/decoding and for pretty printing. It must not be used by any other <code>field</code> in the record.</p><p>For instance:</p><pre><code>type manuscript = { title : string option }

let manuscript = field &quot;title&quot; (option string) (fun t -&gt; t.title)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-(|+)" class="anchored"><a href="#val-(|+)" class="anchor"></a><code><span><span class="keyword">val</span> (|+) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <a href="#type-open_record">open_record</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>)</span> <a href="#type-open_record">open_record</a></span></span></code></div><div class="spec-doc"><p><code>r |+ f</code> is the open record <code>r</code> augmented with the field <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sealr" class="anchored"><a href="#val-sealr" class="anchor"></a><code><span><span class="keyword">val</span> sealr : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span>)</span> <a href="#type-open_record">open_record</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sealr r</code> seals the open record <code>r</code>. <b>Raises.</b> <code>Invalid_argument</code> if two or more fields share the same name.</p></div></div><p>Putting all together:</p><pre><code>type menu = { restaurant : string; items : (string * int32) list }

let t =
  record &quot;t&quot; (fun restaurant items -&gt; { restaurant; items })
  |+ field &quot;restaurant&quot; string (fun t -&gt; t.restaurant)
  |+ field &quot;items&quot; (list (pair string int32)) (fun t -&gt; t.items)
  |&gt; sealr</code></pre><h2 id="variants"><a href="#variants" class="anchor"></a>Variants</h2><div class="odoc-spec"><div class="spec type" id="type-open_variant" class="anchored"><a href="#type-open_variant" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c) open_variant</span></span></code></div><div class="spec-doc"><p>The type for representing open variants of type <code>'a</code> with pattern matching of type <code>'b</code>. <code>'c</code> represents the remaining constructors to be described using the <a href="#val-(|~)"><code>(|~)</code></a> operator. An open variant initially satisfies <code>c' = 'b</code> and can be <a href="#val-sealv">sealed</a> once <code>'c = 'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-variant" class="anchored"><a href="#val-variant" class="anchor"></a><code><span><span class="keyword">val</span> variant : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>)</span> <a href="#type-open_variant">open_variant</a></span></span></code></div><div class="spec-doc"><p><code>variant n p</code> is an incomplete representation of the variant type called <code>n</code> of type <code>'a</code> using <code>p</code> to deconstruct values. To complete the representation, add cases with <a href="#val-(|~)"><code>(|~)</code></a> and then seal the variant with <a href="#val-sealv"><code>sealv</code></a>.</p><p>The name <code>n</code> is used for non-binary encoding/decoding and for pretty printing.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-case" class="anchored"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) case</span></span></code></div><div class="spec-doc"><p>The type for representing variant cases of type <code>'a</code> with patterns of type <code>'b</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-case_p" class="anchored"><a href="#type-case_p" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a case_p</span></span></code></div><div class="spec-doc"><p>The type for representing patterns for a variant of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-case0" class="anchored"><a href="#val-case0" class="anchor"></a><code><span><span class="keyword">val</span> case0 : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="#type-case_p">case_p</a></span>)</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p><code>case0 n v</code> is a representation of a variant constructor <code>v</code> with no arguments and name <code>n</code>. <b>Raises.</b> <code>Invalid_argument</code> if <code>n</code> is not valid UTF-8.</p><p>The name <code>n</code> is used for non-binary encoding/decoding and for pretty printing. It must not by used by any other <code>case0</code> in the record.</p><p>For instance:</p><pre><code>type t = Foo

let foo = case0 &quot;Foo&quot; Foo</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-case1" class="anchored"><a href="#val-case1" class="anchor"></a><code><span><span class="keyword">val</span> case1 : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-case_p">case_p</a></span>)</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p><code>case1 n t c</code> is a representation of a variant constructor <code>c</code> with an argument of type <code>t</code> and name <code>n</code>. <b>Raises.</b> <code>Invalid_argument</code> if <code>n</code> is not valid UTF-8.</p><p>The name <code>n</code> is used for non-binary encoding/decoding and for pretty printing. It must not by used by any other <code>case1</code> in the record.</p><p>For instance:</p><pre><code>type t = Foo of string

let foo = case1 &quot;Foo&quot; string (fun s -&gt; Foo s)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-(|~)" class="anchored"><a href="#val-(|~)" class="anchor"></a><code><span><span class="keyword">val</span> (|~) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <a href="#type-open_variant">open_variant</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="#type-case">case</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>)</span> <a href="#type-open_variant">open_variant</a></span></span></code></div><div class="spec-doc"><p><code>v |~ c</code> is the open variant <code>v</code> augmented with the case <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sealv" class="anchored"><a href="#val-sealv" class="anchor"></a><code><span><span class="keyword">val</span> sealv : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-case_p">case_p</a></span>)</span> <a href="#type-open_variant">open_variant</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sealv v</code> seals the open variant <code>v</code>. <b>Raises.</b> <code>Invalid_argument</code> if two or more cases of same arity share the same name.</p></div></div><p>Putting all together:</p><pre><code>type t = Foo | Bar of string

let t =
  variant &quot;t&quot; (fun foo bar -&gt; function Foo -&gt; foo | Bar s -&gt; bar s)
  |~ case0 &quot;Foo&quot; Foo
  |~ case1 &quot;Bar&quot; string (fun x -&gt; Bar x)
  |&gt; sealv</code></pre><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>enum n cs</code> is a representation of the variant type called <code>n</code> with singleton cases <code>cs</code>. e.g.</p><pre><code>type t = Foo | Bar | Toto

let t = enum &quot;t&quot; [ (&quot;Foo&quot;, Foo); (&quot;Bar&quot;, Bar); (&quot;Toto&quot;, Toto) ]</code></pre><p>The name <code>n</code> and the case names are used for non-binary encoding/decoding and for pretty printing. <b>Raises.</b> <code>Invalid_argument</code> if two or more cases share the same name.</p></div></div><h2 id="recursive"><a href="#recursive" class="anchor"></a>Recursive definitions</h2><p><code>Repr</code> allows a limited description of recursive records and variants.</p><p><b>TODO</b>: describe the limitations, e.g. only regular recursion and no use of the generics inside the <code>mu*</code> functions and the usual caveats with recursive values (such as infinite loops on most of the generics which don't check sharing).</p><div class="odoc-spec"><div class="spec value" id="val-mu" class="anchored"><a href="#val-mu" class="anchor"></a><code><span><span class="keyword">val</span> mu : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mu f</code> is the representation <code>r</code> such that <code>r = mu r</code>.</p><p>For instance:</p><pre><code>type x = { x : x option }

let x =
  mu (fun x -&gt;
      record &quot;x&quot; (fun x -&gt; { x })
      |+ field &quot;x&quot; (option x) (fun x -&gt; x.x)
      |&gt; sealr)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-mu2" class="anchored"><a href="#val-mu2" class="anchor"></a><code><span><span class="keyword">val</span> mu2 : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mu2 f</code> is the representations <code>r</code> and <code>s</code> such that <code>r, s = mu2 r s</code>.</p><p>For instance:</p><pre><code>type r = { foo : int; bar : string list; z : z option }

and z = { x : int; r : r list }

(* Build the representation of [r] knowing [z]'s. *)
let mkr z =
  record &quot;r&quot; (fun foo bar z -&gt; { foo; bar; z })
  |+ field &quot;foo&quot; int (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |+ field &quot;z&quot; (option z) (fun t -&gt; t.z)
  |&gt; sealr

(* And the representation of [z] knowing [r]'s. *)
let mkz r =
  record &quot;z&quot; (fun x r -&gt; { x; r })
  |+ field &quot;x&quot; int (fun t -&gt; t.x)
  |+ field &quot;r&quot; (list r) (fun t -&gt; t.r)
  |&gt; sealr

(* Tie the loop. *)
let r, z = mu2 (fun r z -&gt; (mkr z, mkz y))</code></pre></div></div><h2 id="staging"><a href="#staging" class="anchor"></a>Staging</h2><div class="odoc-spec"><div class="spec type" id="type-staged" class="anchored"><a href="#type-staged" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a staged</span></span></code></div><div class="spec-doc"><p>The type for staged operations.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stage" class="anchored"><a href="#val-stage" class="anchor"></a><code><span><span class="keyword">val</span> stage : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>stage x</code> stages <code>x</code>, where <code>x</code> would typically be a function that is expensive to construct.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unstage" class="anchored"><a href="#val-unstage" class="anchor"></a><code><span><span class="keyword">val</span> unstage : <span><span><span class="type-var">'a</span> <a href="#type-staged">staged</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>unstage x</code> unstages <code>x</code>.</p><p>Both <code>stage</code> and <code>unstage</code> are implemented with the identity function.</p><p>As the <a href="#generics">generic operations</a> tend to be used repeatedly with the same left-most parameters, this type trick encourages the user to specialise them only once for performance reasons.</p><p>For instance:</p><pre><code>let t = Repr.(pair int bool)
let compare = Repr.(unstage (compare t))

let sorted_list =
  List.init 42_000 (fun _ -&gt; (Random.int 100_000, Random.bool ()))
  |&gt; List.sort compare</code></pre></div></div><h2 id="generics"><a href="#generics" class="anchor"></a>Generic Operations</h2><p>Given a value <code>'a t</code>, it is possible to define generic operations on value of type <code>'a</code> such as pretty-printing, parsing and unparsing.</p><div class="odoc-spec"><div class="spec type" id="type-equal" class="anchored"><a href="#type-equal" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a equal</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>equal t</code> is the equality function between values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-compare" class="anchored"><a href="#type-compare" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a compare</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-compare">compare</a></span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>compare t</code> compares values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pp" class="anchored"><a href="#type-pp" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a pp</span></span><span> = <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The type for pretty-printers.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-of_string" class="anchored"><a href="#type-of_string" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a of_string</span></span><span> = <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>The type for parsers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-pp">pp</a></span></span></code></div><div class="spec-doc"><p><code>pp t</code> is the pretty-printer for values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dump" class="anchored"><a href="#val-pp_dump" class="anchor"></a><code><span><span class="keyword">val</span> pp_dump : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-pp">pp</a></span></span></code></div><div class="spec-doc"><p><code>pp_dump t</code> is the dump pretty-printer for values of type <code>t</code>.</p><p>This pretty-printer outputs an encoding which is as close as possible to native OCaml syntax, so that the result can easily be copy-pasted into an OCaml REPL to inspect the value further.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_ty" class="anchored"><a href="#val-pp_ty" class="anchor"></a><code><span><span class="keyword">val</span> pp_ty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-pp">pp</a></span></span></code></div><div class="spec-doc"><p>The pretty printer for generics of type <a href="#type-t"><code>t</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string t</code> is <code>Fmt.to_to_string (pp t)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-of_string">of_string</a></span></span></code></div><div class="spec-doc"><p><code>of_string t</code> parses values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-random" class="anchored"><a href="#val-random" class="anchor"></a><code><span><span class="keyword">val</span> random : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>random t</code> is a random value generator for values of type <code>t</code>. For bounded types, values are sampled uniformly; for unbounded ones (lists, strings etc.), the length is first chosen according to a geometric distribution.</p><p>Derived generators use the global PRNG state provided by <code>Stdlib</code>.Random.get_state.</p><p>NOTE: this generator may fail to terminate when sampling a recursive type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-random_state" class="anchored"><a href="#val-random_state" class="anchor"></a><code><span><span class="keyword">val</span> random_state : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>random_state</code> is a variant of <a href="#val-random"><code>random</code></a> that takes an explicit PRNG state to use for random generation.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ty" class="anchored"><a href="#type-ty" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ty</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Attribute" class="anchored"><a href="#module-Attribute" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Attribute/index.html">Attribute</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Attributes provide a mechanism for attaching metadata to type representations.</p></div></div><h3 id="json-converters"><a href="#json-converters" class="anchor"></a>JSON converters</h3><div class="odoc-spec"><div class="spec module" id="module-Json" class="anchored"><a href="#module-Json" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Json/index.html">Json</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Overlay on top of Jsonm to work with rewindable streams.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-encode_json" class="anchored"><a href="#type-encode_json" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a encode_json</span></span><span> = <span><span class="xref-unresolved">Jsonm</span>.encoder <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The type for JSON encoders.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-decode_json" class="anchored"><a href="#type-decode_json" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a decode_json</span></span><span> = <span><a href="Json/index.html#type-decoder">Json.decoder</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>The type for JSON decoders.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_json" class="anchored"><a href="#val-pp_json" class="anchor"></a><code><span><span class="keyword">val</span> pp_json : <span>?minify:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-pp_dump"><code>pp_dump</code></a> but pretty-prints the JSON representation instead of the OCaml one. See <a href="#val-encode_json"><code>encode_json</code></a> for details about the encoding.</p><p>For instance:</p><pre><code>type t = { foo : int option; bar : string list }

let t =
  record &quot;r&quot; (fun foo bar -&gt; { foo; bar })
  |+ field &quot;foo&quot; (option int) (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |&gt; sealr

let s = Fmt.str &quot;%a\n&quot; (pp t) { foo = None; bar = [ &quot;foo&quot; ] }

(* s is &quot;{ foo = None; bar = [\&quot;foo\&quot;]; }&quot; *)

let j = Fmt.str &quot;%a\n&quot; (pp_json t) { foo = None; bar = [ &quot;foo&quot; ] }

(* j is &quot;{ \&quot;bar\&quot;:[\&quot;foo\&quot;] }&quot; *)</code></pre><p><b>NOTE:</b> this will automatically convert JSON fragments to valid JSON objects by adding an enclosing array if necessary.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encode_json" class="anchored"><a href="#val-encode_json" class="anchor"></a><code><span><span class="keyword">val</span> encode_json : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonm</span>.encoder <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>encode_json t e</code> encodes <code>t</code> into the <a href="http://erratique.ch/software/jsonm">jsonm</a> encoder <code>e</code>. The encoding is a relatively straightforward translation of the OCaml structure into JSON. The main highlights are:</p><ul><li>The unit value <code>()</code> is translated into the empty object <code>{}</code>.</li><li>OCaml ints are translated into JSON floats.</li><li>OCaml strings are translated into JSON strings. You must then ensure that the OCaml strings contains only valid UTF-8 characters.</li><li>OCaml options are translated differently depending on context: record fields with a value of <code>None</code> are removed from the JSON object; record fields with a value of <code>Some x</code> are automatically unboxed into x; and outside of records, <code>None</code> is translated into <code>null</code> and <code>Some x</code> into <code>{&quot;some&quot;: x'}</code> with <code>x'</code> the JSON encoding of <code>x</code>.</li><li>Variant cases built using <a href="#val-case0"><code>case0</code></a> are represented as strings.</li><li>Variant cases built using <a href="#val-case1"><code>case1</code></a> are represented as a record with one field; the field name is the name of the variant.</li></ul><p><b>NOTE:</b> this can be used to encode JSON fragments. It's the responsibility of the caller to ensure that the encoded JSON fragment fits properly into a well-formed JSON object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decode_json" class="anchored"><a href="#val-decode_json" class="anchor"></a><code><span><span class="keyword">val</span> decode_json : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonm</span>.decoder <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>decode_json t e</code> decodes values of type <code>t</code> from the <a href="http://erratique.ch/software/jsonm">jsonm</a> decoder <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decode_json_lexemes" class="anchored"><a href="#val-decode_json_lexemes" class="anchor"></a><code><span><span class="keyword">val</span> decode_json_lexemes : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Jsonm</span>.lexeme list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>decode_json_lexemes</code> is similar to <a href="#val-decode_json"><code>decode_json</code></a> but uses an already decoded list of JSON lexemes instead of a decoder.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_json_string" class="anchored"><a href="#val-to_json_string" class="anchor"></a><code><span><span class="keyword">val</span> to_json_string : <span>?minify:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_json_string</code> is <a href="#val-encode_json"><code>encode_json</code></a> with a string encoder.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_json_string" class="anchored"><a href="#val-of_json_string" class="anchor"></a><code><span><span class="keyword">val</span> of_json_string : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_json_string</code> is <a href="#val-decode_json"><code>decode_json</code></a> with a string decoder .</p></div></div><h3 id="binary-converters"><a href="#binary-converters" class="anchor"></a>Binary Converters</h3><div class="odoc-spec"><div class="spec type" id="type-encode_bin" class="anchored"><a href="#type-encode_bin" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a encode_bin</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The type for binary encoders.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-decode_bin" class="anchored"><a href="#type-decode_bin" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a decode_bin</span></span><span> = <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>int <span class="xref-unresolved">Stdlib</span>.ref</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>The type for binary decoders.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-size_of" class="anchored"><a href="#type-size_of" class="anchor"></a><code><span><span class="keyword">type</span> <span>-'a size_of</span></span></code></div><div class="spec-doc"><p>The type for size function related to binary encoder/decoders.</p></div></div><div class="odoc-spec"><div class="spec type subst" id="type-short_hash" class="anchored"><a href="#type-short_hash" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a short_hash</span></span><span> := <span>?seed:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-short_hash" class="anchored"><a href="#val-short_hash" class="anchor"></a><code><span><span class="keyword">val</span> short_hash : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-short_hash">short_hash</a></span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>hash t x</code> is a short hash of <code>x</code> of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pre_hash" class="anchored"><a href="#val-pre_hash" class="anchor"></a><code><span><span class="keyword">val</span> pre_hash : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>pre_hash t x</code> is the string representation of <code>x</code>, of type <code>t</code>, which will be used to compute the digest of the value. By default it's <code>to_bin_string t x</code> but it can be overriden by <a href="#val-like"><code>like</code></a> and <a href="#val-map"><code>map</code></a> operators.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encode_bin" class="anchored"><a href="#val-encode_bin" class="anchor"></a><code><span><span class="keyword">val</span> encode_bin : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>encode_bin t</code> is the binary encoder for values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decode_bin" class="anchored"><a href="#val-decode_bin" class="anchor"></a><code><span><span class="keyword">val</span> decode_bin : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>decode_bin t</code> is the binary decoder for values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_bin_string" class="anchored"><a href="#val-to_bin_string" class="anchor"></a><code><span><span class="keyword">val</span> to_bin_string : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>to_bin_string t x</code> use <a href="#val-encode_bin"><code>encode_bin</code></a> to convert <code>x</code>, of type <code>t</code>, to a string.</p><p><b>NOTE:</b> When <code>t</code> is <a href="#val-string"><code>string</code></a> or <a href="#val-bytes"><code>bytes</code></a>, the original buffer <code>x</code> is not prefixed by its size as <a href="#val-encode_bin"><code>encode_bin</code></a> would do. If <code>t</code> is <a href="#val-string"><code>string</code></a>, the result is <code>x</code> (without copy).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bin_string" class="anchored"><a href="#val-of_bin_string" class="anchor"></a><code><span><span class="keyword">val</span> of_bin_string : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>of_bin_string t s</code> is <code>v</code> such that <code>s = to_bin_string t v</code>.</p><p><b>NOTE:</b> When <code>t</code> is <a href="#val-string"><code>string</code></a>, the result is <code>s</code> (without copy).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-size_of" class="anchored"><a href="#val-size_of" class="anchor"></a><code><span><span class="keyword">val</span> size_of : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span>)</span> <a href="#type-staged">staged</a></span></span></code></div><div class="spec-doc"><p><code>size_of t x</code> is either the size of <code>encode_bin t x</code> or the binary encoding of <code>x</code>, if the backend is not able to pre-compute serialisation lengths.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Size" class="anchored"><a href="#module-Size" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Size/index.html">Size</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Unboxed" class="anchored"><a href="#module-Unboxed" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Unboxed/index.html">Unboxed</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Unboxed operations assumes that value being serialized is fully filling the underlying buffer. When that's the case, it is not necessary to prefix the value's binary representation by its size, as it is exactly the buffer's size.</p></div></div><h2 id="abstract-types"><a href="#abstract-types" class="anchor"></a>Abstract types</h2><div class="odoc-spec"><div class="spec value" id="val-abstract" class="anchored"><a href="#val-abstract" class="anchor"></a><code><span><span class="keyword">val</span> abstract : <span>pp:<span><span class="type-var">'a</span> <a href="#type-pp">pp</a></span> <span class="arrow">&#45;&gt;</span></span> <span>of_string:<span><span class="type-var">'a</span> <a href="#type-of_string">of_string</a></span> <span class="arrow">&#45;&gt;</span></span> <span>json:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_json">decode_json</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>bin:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span>
<span class="arrow">&#45;&gt;</span></span> <span>?unboxed_bin:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>equal:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>compare:<span><span class="type-var">'a</span> <a href="#type-compare">compare</a></span> <span class="arrow">&#45;&gt;</span></span> <span>short_hash:<span><span class="type-var">'a</span> <a href="#type-short_hash">short_hash</a></span> <span class="arrow">&#45;&gt;</span></span>
<span>pre_hash:<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The representation of an <i>abstract</i> type, with an internal structure that is opaque to Repr, that supports the generic operations above.</p></div></div><h3 id="overriding-specific-operations"><a href="#overriding-specific-operations" class="anchor"></a>Overriding specific operations</h3><p>For a given type representation, each generic operation can be implemented in one of the following ways:</p><div class="odoc-spec"><div class="spec type" id="type-impl" class="anchored"><a href="#type-impl" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a impl</span></span><span> = </span></code><table><tr id="type-impl.Structural" class="anchored"><td class="def variant constructor"><a href="#type-impl.Structural" class="anchor"></a><code><span>| </span><span><span class="constructor">Structural</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The automatic implementation derived from the type structure.</p><span class="comment-delim">*)</span></td></tr><tr id="type-impl.Custom" class="anchored"><td class="def variant constructor"><a href="#type-impl.Custom" class="anchor"></a><code><span>| </span><span><span class="constructor">Custom</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A hand-written implementation.</p><span class="comment-delim">*)</span></td></tr><tr id="type-impl.Undefined" class="anchored"><td class="def variant constructor"><a href="#type-impl.Undefined" class="anchor"></a><code><span>| </span><span><span class="constructor">Undefined</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An unimplemented operation that raises <a href="#exception-Unsupported_operation"><code>Unsupported_operation</code></a> when invoked.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Unsupported_operation" class="anchored"><a href="#exception-Unsupported_operation" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unsupported_operation</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-partially_abstract" class="anchored"><a href="#val-partially_abstract" class="anchor"></a><code><span><span class="keyword">val</span> partially_abstract : <span>pp:<span><span><span class="type-var">'a</span> <a href="#type-pp">pp</a></span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span>of_string:<span><span><span class="type-var">'a</span> <a href="#type-of_string">of_string</a></span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span>json:<span><span>(<span><span class="type-var">'a</span> <a href="#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_json">decode_json</a></span>)</span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span>
<span>bin:<span><span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unboxed_bin:<span><span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span>equal:<span><span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span>
<span>compare:<span><span><span class="type-var">'a</span> <a href="#type-compare">compare</a></span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span>short_hash:<span><span><span class="type-var">'a</span> <a href="#type-short_hash">short_hash</a></span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span>pre_hash:<span><span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> <a href="#type-impl">impl</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>partially_abstract t</code> is a partially-abstract type with internal representation <code>t</code>. The named arguments specify the implementation of each of the generic operations on this type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-like" class="anchored"><a href="#val-like" class="anchor"></a><code><span><span class="keyword">val</span> like : <span>?pp:<span><span class="type-var">'a</span> <a href="#type-pp">pp</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?of_string:<span><span class="type-var">'a</span> <a href="#type-of_string">of_string</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?json:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_json">decode_json</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?bin:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span>
<span class="arrow">&#45;&gt;</span></span> <span>?unboxed_bin:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?equal:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?compare:<span><span class="type-var">'a</span> <a href="#type-compare">compare</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?short_hash:<span><span class="type-var">'a</span> <a href="#type-short_hash">short_hash</a></span> <span class="arrow">&#45;&gt;</span></span>
<span>?pre_hash:<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A wrapper around <a href="#val-partially_abstract"><code>partially_abstract</code></a> with each operation defaulting to <code>`Structural</code> and admitting a <code>`Custom</code> override.</p><p><b>Note</b>: if <code>~compare</code> is passed and <code>~equal</code> is not then the default equality function <code>(fun x y -&gt; compare x y = 0)</code> will be used.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span>?pp:<span><span class="type-var">'a</span> <a href="#type-pp">pp</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?of_string:<span><span class="type-var">'a</span> <a href="#type-of_string">of_string</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?json:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_json">decode_json</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?bin:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>?unboxed_bin:<span>(<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="#type-size_of">size_of</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?equal:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?compare:<span><span class="type-var">'a</span> <a href="#type-compare">compare</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?short_hash:<span><span class="type-var">'a</span> <a href="#type-short_hash">short_hash</a></span> <span class="arrow">&#45;&gt;</span></span>
<span>?pre_hash:<span><span class="type-var">'a</span> <a href="#type-encode_bin">encode_bin</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>This combinator allows defining a representative of one type in terms of another by supplying coercions between them. For a representative of <code>Stdlib.Map</code>, see <a href="Of_map/index.html"><code>Of_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-DSL" class="anchored"><a href="#module-type-DSL" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-DSL/index.html">DSL</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></div><h2 id="miscellaneous-modules"><a href="#miscellaneous-modules" class="anchor"></a>Miscellaneous modules</h2><div class="odoc-spec"><div class="spec module" id="module-Binary" class="anchored"><a href="#module-Binary" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Binary/index.html">Binary</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module provides functions for interacting with Repr's binary serialisation format directly (without first constructing a representation of the type being encoded). These can be useful for performance-critical applications, where the runtime overhead of the dynamic specialisation is too large, or when the actual codec being used is too complex to be expressed via a type representation.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Staging" class="anchored"><a href="#module-Staging" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Staging/index.html">Staging</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module is intended to be globally opened.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Witness" class="anchored"><a href="#module-Witness" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Witness/index.html">Witness</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>